---
title: "homecage"
author: "Rayna M Harris"
date: "2/24/2017"
output: md_document
---

## Loading the data
In the summer of 2016, I processed a bunch of hippocampal tissue samples from WT and FMR1-KO mice that were trained in an active place avoidance task. 

This data was added the the epically large sample collection database contained in the two files  "animals.csv" and "punches.csv" which provided a detailed account of all animals processed and all tissue samples collected. Then, I tidy the dataframe a little bit to get it prepared for RNAseq sample submision.

```{r install packages load data, warning=FALSE, message=FALSE}
#install.packages("tidyr", dependencies=TRUE)
library("tidyr") 
library("dplyr") ## for filtering and selecting rows
library("plyr")  ## for renmaing factors
library("reshape2") ##  for melting dataframe
library("ggplot2") ## for awesome plots!
library("magrittr") ## to use the weird pipe
library("gplots") ##for making awesome plots
library("cowplot") ## for some easy to use themes
library("DESeq2") ## for differnetial gene expression profiling
# set output file for figures 
knitr::opts_chunk$set(fig.path = '../figures/homecage/')
```

## Subsetting the data
This analysis will focus only on the anaimals process in 2016. I collected many, many samples, but I only processed a subset. I conducted a photo anlaysis first to decide which samples came from a very specific location in the hippocampus. 



## Data Cleaning
Well, the words I used when collecting might not be exactly what I want plotted on figures and such, so I need to do a little data cleaning. I also need to get the data in order so that row names are informative and contain information

```{r data cleaning}
## start after 02c_tpmbygene
Traits <- read.csv("../data/homecage.csv", header=TRUE)
rownames(Traits) <- Traits$RNAseqID    # set $genoAPAsessionInd as
str(Traits)
```


## Kallisto Gather

The kallisto output gives you read counts for sample in an abundance file for every single sample. This portion of the code goes through and finds each samples' abundance.tsv file, extracts the data, and combines it all into a dataframe. The "counts" file is unnormalized, but the "tpm" is the data after being normalized by transcripts per million. I also use some string splitting to take the very long transcript identifying and create a "geneids" file that has all the database identifiers for each transcript. 

(P.S. Unfortunately, I have no idea how to do this next part without changing directories.)

```{r kallisto gather}
setwd("../data/JA16444/")
## this will create lists of all the samples
kallistoDirs = dir(".")
kallistoDirs = kallistoDirs[!grepl("\\.(R|py|pl|sh|xlsx?|txt|tsv|csv|org|md|obo|png|jpg|pdf)$",
        kallistoDirs, ignore.case=TRUE)]

kallistoFiles = paste0(kallistoDirs, "/abundance.tsv")
names(kallistoFiles) = kallistoDirs
if(file.exists(kallistoFiles))
  kallistoData = lapply(
    kallistoFiles,
    read.table,
    sep = "\t",
    row.names = 1,
    header = TRUE
)

## this for loop uses the reduce function to make two data frame with counts or tpm from all the samples
ids = Reduce(f=union, x=lapply(kallistoData, rownames))
if (all(sapply(kallistoData, function(x) {all(rownames(x)==ids)}))) {
    count = data.frame(
        id = ids,
        sapply(kallistoData, function(x) {x$est_counts}),
        check.names = FALSE,
        stringsAsFactors = FALSE
    )
    tpm = data.frame(
        id = ids,
        sapply(kallistoData, function(x) {x$tpm}),
        check.names = FALSE,
        stringsAsFactors = FALSE
    )
}

## make a dataframe with the parts of the gene id as columns
geneids <- count[c(1)] 
geneids$ENSMUST <- sapply(strsplit(as.character(geneids$id),'\\|'), "[", 1)
geneids$ENSMUSG <- sapply(strsplit(as.character(geneids$id),'\\|'), "[", 2)
geneids$OTTMUSG <- sapply(strsplit(as.character(geneids$id),'\\|'), "[", 3)
geneids$OTTMUST <- sapply(strsplit(as.character(geneids$id),'\\|'), "[", 4)
geneids$transcript <- sapply(strsplit(as.character(geneids$id),'\\|'), "[", 5)
geneids$gene <- sapply(strsplit(as.character(geneids$id),'\\|'), "[", 6)
geneids$length <- sapply(strsplit(as.character(geneids$id),'\\|'), "[", 7)
geneids$structure1 <- sapply(strsplit(as.character(geneids$id),'\\|'), "[", 8)
geneids$structure2 <- sapply(strsplit(as.character(geneids$id),'\\|'), "[", 9)
geneids$structure3 <- sapply(strsplit(as.character(geneids$id),'\\|'), "[", 10)
geneids$transcript_lenght <- as.factor(paste(geneids$transcript, geneids$length, sep="_"))

## prep data for wgcna
countswgcna <- count
row.names(countswgcna) <- geneids$transcript_lenght
countswgcna[1] <- NULL
countswgcna <- round(countswgcna)
summary(countswgcna)

## prep data for wgcna
tpmswgcna <- tpm
row.names(tpmswgcna) <- geneids$transcript_lenght
tpmswgcna[1] <- NULL
tpmswgcna <- round(tpmswgcna)
summary(tpmswgcna)
```

## Merge transcipts counts to gene counts

Kallisto is cool because it does give you transcript level stuff, but right now I think I have more power if I just look at gene level stuff. I'll go back and look at transcripts if I want to.

```{r tpmbygene}
# merge tpm and gene id dataframe
tpmbygene <-  full_join(geneids, tpm)
str(tpmbygene)
head(tpmbygene)

countbygene <- full_join(geneids, count)
str(countbygene)


## remove unnecesary columns (aka, keep gene name and counts for samples)
tpmbygene <- tpmbygene[-c(1:6,8:12)]  
countbygene <- countbygene[-c(1:6,8:12)]  

## lenghten 
tpmbygene <- melt(tpmbygene, id=c("gene"))
head(tpmbygene)

countbygene <- melt(countbygene, id=c("gene"))
head(countbygene)

#then widen by sum
tpmbygene <- dcast(tpmbygene, gene ~ variable, value.var= "value", fun.aggregate=mean)
countbygene  <- dcast(countbygene, gene ~ variable, value.var= "value", fun.aggregate=mean)

## make gene the row name then round all value to nearest 1s place
row.names(tpmbygene) <- tpmbygene$gene
tpmbygene[1] <- NULL
tpmbygene <- round(tpmbygene)
summary(tpmbygene)
head(tpmbygene)

row.names(countbygene) <- countbygene$gene
countbygene[1] <- NULL
countbygene <- round(countbygene)
summary(countbygene)

```




## DESeq Analysis

Now, I'll look for differential gene expression between the FMR1-KO and WT mice. This analysis was developed by reading the DESEq manual. In many place, I try to provide the chapter where these steps are described in more details.

```{r DESeq}
# 1.3.3 Count matrix input ----
countData <- countbygene 
colData <- Traits %>%
  arrange(RNAseqID) # needs to be in same order a countData
head(countData)
head(colData)

## making sure colData and countData have the same number of rows
savecols <- as.character(colData$RNAseqID) #select the sample name column that corresponds to row names
savecols <- as.vector(savecols) # make it a vector
countData <- countData %>% select(one_of(savecols)) # select just the columns that match the samples in colData

## remove genes with total counts across all samples < 2
countData[countData < 2] <- 0

## differential gene expression
dds <- DESeqDataSetFromMatrix(countData = countData,
                              colData = colData,
                              design = ~ Group + Punch)
dds


## 1.3.6 Pre-filtering
dds <- dds[ rowSums(counts(dds)) > 1, ]

## 1.3.7 Note on factor levels
dds$Group <- factor(dds$Group, levels=c("homecage","yoked"))
dds$Punch <- factor(dds$Punch, levels=c("DG","CA1", "CA3"))

## 1.4  Differential expression analysi
dds <- DESeq(dds)

# general deseq
res <- results(dds, independentFiltering = F)
resOrdered <- res[order(res$padj),]
summary(res)
head(resOrdered,10)
sum(res$padj < 0.1, na.rm = TRUE) 
res05 <- results(dds, alpha=0.05)
summary(res05) 
table(res05$padj < .05)
sum(res05$padj < 0.05, na.rm=TRUE)


## 1.5 exploring and reporting results

plotMA(res, main="plotMA")

resMLE <- results(dds)
head(resMLE, 4)

hist(res$pvalue[res$baseMean > 1], breaks=0:20/20, col="grey50", border="white")

plotCounts(dds, gene=which.min(res$padj), intgroup="Group")
plotCounts(dds, gene=which.min(res$padj), intgroup="Punch")

respadj <- as.data.frame(res$padj)
head(respadj)

## 1.5 more info
mcols(res)$description

## for variance stablized gene expression and log transformed data
rld <- rlog(dds, blind=FALSE)
vsd <- varianceStabilizingTransformation(dds, blind=FALSE)
vsd.fast <- vst(dds, blind=FALSE)
head(assay(rld), 3)

```


## pca plot

```{r pca}
pcaData <- plotPCA(rld, intgroup = c( "Group", "Punch"), returnData=TRUE)
pcaData
percentVar <- round(100 * attr(pcaData, "percentVar"))

ggplot(pcaData, aes(PC1, PC2, color=Group, shape = Punch)) + geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) +
  coord_fixed()
```

```{r heatmap}
library("genefilter")
library("pheatmap")
topVarGenes <- head(order(rowVars(assay(rld)),decreasing=TRUE),25)
mat <- assay(rld)[ topVarGenes, ]
mat <- mat - rowMeans(mat)
df <- as.data.frame(colData(rld)[,c("Group", "Punch")])
pheatmap(mat)
pheatmap(mat, show_colnames=F, show_rownames = T,
         annotation_col=df)
```



## Session Info
```{r session info}
sessionInfo()
```